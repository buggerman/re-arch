name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version
        id: get_version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Generate changelog
        id: changelog
        run: |
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -n "$PREVIOUS_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s" $PREVIOUS_TAG..HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s")
          fi
          
          # Create changelog file
          cat > CHANGELOG.md << EOF
          # Changes in ${{ steps.get_version.outputs.version }}
          
          $CHANGELOG
          
          **Full Changelog**: https://github.com/buggerman/re-arch/compare/${PREVIOUS_TAG}...${{ steps.get_version.outputs.version }}
          EOF
          
          echo "changelog_file=CHANGELOG.md" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          release_name: Re-Arch ${{ steps.get_version.outputs.version }}
          body_path: CHANGELOG.md
          draft: false
          prerelease: false

  build-packages:
    name: Build Release Packages
    needs: create-release
    runs-on: ubuntu-latest
    strategy:
      matrix:
        format: [tar.gz, zip, deb]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup build environment
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential fakeroot devscripts

      - name: Prepare release files
        run: |
          mkdir -p release/re-arch
          cp re-arch.sh release/re-arch/
          cp README.md release/re-arch/
          cp LICENSE release/re-arch/
          cp -r docs release/re-arch/ 2>/dev/null || true
          cp -r configs release/re-arch/ 2>/dev/null || true
          
          # Create install script
          cat > release/re-arch/install.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail
          
          INSTALL_DIR="/usr/local/bin"
          SCRIPT_NAME="re-arch"
          
          echo "Installing Re-Arch..."
          
          # Copy script
          sudo cp re-arch.sh "$INSTALL_DIR/$SCRIPT_NAME"
          sudo chmod +x "$INSTALL_DIR/$SCRIPT_NAME"
          
          # Copy update scripts (they will be deployed by the main script)
          echo "Installation complete!"
          echo "Run 'sudo re-arch --help' to get started"
          EOF
          
          chmod +x release/re-arch/install.sh

      - name: Build tar.gz package
        if: matrix.format == 'tar.gz'
        run: |
          cd release
          tar -czf re-arch-${{ needs.create-release.outputs.version }}.tar.gz re-arch/

      - name: Build zip package
        if: matrix.format == 'zip'
        run: |
          cd release
          zip -r re-arch-${{ needs.create-release.outputs.version }}.zip re-arch/

      - name: Build deb package
        if: matrix.format == 'deb'
        run: |
          # Create Debian package structure
          mkdir -p package/re-arch/DEBIAN
          mkdir -p package/re-arch/usr/local/bin
          mkdir -p package/re-arch/usr/share/doc/re-arch
          
          # Copy files
          cp release/re-arch/re-arch.sh package/re-arch/usr/local/bin/re-arch
          cp release/re-arch/README.md package/re-arch/usr/share/doc/re-arch/
          cp release/re-arch/LICENSE package/re-arch/usr/share/doc/re-arch/
          
          # Create control file
          cat > package/re-arch/DEBIAN/control << EOF
          Package: re-arch
          Version: ${{ needs.create-release.outputs.version }}
          Section: admin
          Priority: optional
          Architecture: all
          Maintainer: Re-Arch Team <noreply@example.com>
          Description: Atomic Arch Linux Converter
           Converts a minimal Arch Linux installation into an atomic system
           with Btrfs subvolumes and snapshot-based updates.
          Depends: bash (>= 4.0), btrfs-progs, parted, coreutils
          EOF
          
          # Create postinst script
          cat > package/re-arch/DEBIAN/postinst << 'EOF'
          #!/bin/bash
          chmod +x /usr/local/bin/re-arch
          echo "Re-Arch installed successfully!"
          echo "Run 'sudo re-arch --help' to get started"
          EOF
          chmod +x package/re-arch/DEBIAN/postinst
          
          # Build package
          dpkg-deb --build package/re-arch
          mv package/re-arch.deb release/re-arch-${{ needs.create-release.outputs.version }}.deb

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: release/re-arch-${{ needs.create-release.outputs.version }}.${{ matrix.format }}
          asset_name: re-arch-${{ needs.create-release.outputs.version }}.${{ matrix.format }}
          asset_content_type: application/octet-stream

  build-container:
    name: Build Container Image
    needs: create-release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Create Dockerfile
        run: |
          cat > Dockerfile << 'EOF'
          FROM archlinux:latest
          
          # Install dependencies
          RUN pacman -Sy --noconfirm bash btrfs-progs parted coreutils util-linux
          
          # Create app directory
          WORKDIR /app
          
          # Copy application
          COPY re-arch.sh /usr/local/bin/re-arch
          COPY README.md LICENSE ./
          COPY docs/ ./docs/ 2>/dev/null || true
          COPY configs/ ./configs/ 2>/dev/null || true
          
          # Make script executable
          RUN chmod +x /usr/local/bin/re-arch
          
          # Create non-root user for testing
          RUN useradd -m -s /bin/bash rearch
          
          # Set up entrypoint
          ENTRYPOINT ["/usr/local/bin/re-arch"]
          CMD ["--help"]
          EOF

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  update-documentation:
    name: Update Documentation
    needs: [create-release, build-packages]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update README with latest version
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          sed -i "s|curl -fsSL https://raw.githubusercontent.com/.*/main/install.sh|curl -fsSL https://github.com/${{ github.repository }}/releases/download/$VERSION/install.sh|g" README.md

      - name: Update install script
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          cat > install.sh << EOF
          #!/bin/bash
          set -euo pipefail
          
          VERSION="$VERSION"
          REPO="${{ github.repository }}"
          INSTALL_DIR="/usr/local/bin"
          SCRIPT_NAME="re-arch"
          
          echo "Installing Re-Arch \$VERSION..."
          
          # Download and install
          curl -fsSL "https://github.com/\$REPO/releases/download/\$VERSION/re-arch-\$VERSION.tar.gz" | tar -xz
          sudo cp re-arch/re-arch.sh "\$INSTALL_DIR/\$SCRIPT_NAME"
          sudo chmod +x "\$INSTALL_DIR/\$SCRIPT_NAME"
          
          # Cleanup
          rm -rf re-arch/
          
          echo "Installation complete!"
          echo "Run 'sudo re-arch --help' to get started"
          EOF
          chmod +x install.sh

      - name: Commit documentation updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md install.sh
          git diff --staged --quiet || git commit -m "Update documentation for release ${{ needs.create-release.outputs.version }}"
          git push

  notify-release:
    name: Notify Release
    needs: [create-release, build-packages, build-container, update-documentation]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Release Success Notification
        if: ${{ needs.create-release.result == 'success' && needs.build-packages.result == 'success' }}
        run: |
          echo "ðŸŽ‰ Release ${{ needs.create-release.outputs.version }} created successfully!"
          echo "ðŸ“¦ Packages built and uploaded"
          echo "ðŸ³ Container image published"
          echo "ðŸ“š Documentation updated"

      - name: Release Failure Notification
        if: ${{ needs.create-release.result == 'failure' || needs.build-packages.result == 'failure' }}
        run: |
          echo "âŒ Release ${{ needs.create-release.outputs.version }} failed!"
          echo "Create Release: ${{ needs.create-release.result }}"
          echo "Build Packages: ${{ needs.build-packages.result }}"
          echo "Build Container: ${{ needs.build-container.result }}"
          exit 1